<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>飞机大战 (H5)</title>

    <style>
        /* CSS Reset 和全屏设置 */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* 防止页面滚动 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #111;
            color: #fff;
        }

        /* 游戏容器：用于定位所有UI元素 */
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #000;
        }

        /* 游戏画布 */
        #game-canvas {
            width: 100%;
            height: 100%;
            display: none; /* 默认隐藏，游戏开始时显示 */
            background-color: #000;
        }

        /* 菜单通用样式 */
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
        }

        .menu h1, .menu h2 {
            margin-bottom: 20px;
        }
        .menu input, .menu button {
            font-size: 16px;
            padding: 12px;
            margin: 10px 0;
            width: 100%;
            border-radius: 5px;
            border: none;
        }
        .menu button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
        }
        .menu button:hover {
            background-color: #45a049;
        }

        /* 排行榜列表 */
        #high-score-list {
            text-align: left;
            margin: 20px auto 0;
            padding-left: 30px;
            list-style: decimal;
        }
        #high-score-list li {
            font-size: 18px;
            margin-bottom: 5px;
        }

        /* 游戏中的UI元素 */
        #score-display {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            z-index: 5;
            display: none; /* 游戏开始时显示 */
        }

        /* 关键：移动端开火按钮 */
        #fire-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%; /* 圆形按钮 */
            z-index: 5;
            display: none; /* 游戏开始时显示 */
            
            /* 防止点击时出现蓝色高亮 */
            -webkit-tap-highlight-color: transparent; 
        }
        #fire-button:active {
            background-color: rgba(255, 0, 0, 0.8); /* 按下时变色 */
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="start-menu" class="menu">
            <h1>飞机大战</h1>
            <input type="text" id="player-name-input" placeholder="输入你的名字">
            <button id="start-button">开始游戏</button>
            <h3>本地最高分 (Top 10):</h3>
            <ol id="high-score-list"></ol>
        </div>

        <canvas id="game-canvas"></canvas>

        <div id="score-display">得分: 0</div>
        <button id="fire-button"></button>

        <div id="game-over-menu" class="menu" style="display: none;">
            <h2>游戏结束</h2>
            <p style="font-size: 20px; margin: 15px 0;">
                最终得分: <span id="final-score">0</span>
            </p>
            <button id="restart-button">重新开始</button>
            <button id="main-menu-button">返回主菜单</button>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // === 1. DOM 元素获取 ===
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const startMenu = document.getElementById('start-menu');
            const gameOverMenu = document.getElementById('game-over-menu');
            const startButton = document.getElementById('start-button');
            const restartButton = document.getElementById('restart-button');
            const mainMenuButton = document.getElementById('main-menu-button');
            const playerNameInput = document.getElementById('player-name-input');
            const highScoreList = document.getElementById('high-score-list');
            const finalScoreEl = document.getElementById('final-score');
            const scoreDisplay = document.getElementById('score-display');
            const fireButton = document.getElementById('fire-button');

            // === 2. 游戏变量 ===
            let player, bullets, enemies, missiles, score, gameLoopId, playerName;
            let gameIsOver = false;
            let isFiring = false; // 玩家是否按住开火
            let lastEnemySpawn = 0;
            let enemySpawnInterval = 1000; // 敌人生成间隔 (ms)
            const playerSize = { width: 50, height: 50 }; // 玩家贴图大小
            const enemySize = { width: 50, height: 50 }; // 敌人贴图大小

            // === 3. 加载贴图 ===
            const playerImg = new Image();
            playerImg.src = 'assets/player.png';

            const enemy1Img = new Image(); // 不会射击
            enemy1Img.src = 'assets/player1.png';

            const enemy2Img = new Image(); // 会射击 (跟踪型)
            enemy2Img.src = 'assets/player2.png';

            // === 4. 排行榜 (LocalStorage) ===
            const HIGH_SCORES_KEY = 'planeShooterHighScores';

            function getHighScores() {
                const scores = localStorage.getItem(HIGH_SCORES_KEY);
                return scores ? JSON.parse(scores) : [];
            }

            function saveHighScore(name, score) {
                if (score === 0) return; // 0分不记录
                const scores = getHighScores();
                scores.push({ name, score });
                scores.sort((a, b) => b.score - a.score);
                const top10 = scores.slice(0, 10);
                localStorage.setItem(HIGH_SCORES_KEY, JSON.stringify(top10));
            }

            function displayHighScores() {
                const scores = getHighScores();
                highScoreList.innerHTML = ''; // 清空
                if (scores.length === 0) {
                    highScoreList.innerHTML = '<li>暂无记录</li>';
                } else {
                    scores.forEach(item => {
                        const li = document.createElement('li');
                        li.textContent = `${item.name}: ${item.score}`;
                        highScoreList.appendChild(li);
                    });
                }
            }

            // === 5. 游戏状态管理 ===
            
            // 页面加载时显示排行榜
            displayHighScores();

            // 监听按钮
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            mainMenuButton.addEventListener('click', () => {
                gameOverMenu.style.display = 'none';
                startMenu.style.display = 'block';
                displayHighScores(); // 刷新排行榜
            });

            function startGame() {
                playerName = playerNameInput.value || '匿名玩家';
                
                // 设置画布全屏
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // 初始化游戏
                player = { 
                    x: canvas.width / 2 - playerSize.width / 2, 
                    y: canvas.height - playerSize.height - 80, // 底部
                    width: playerSize.width, 
                    height: playerSize.height,
                    lastShotTime: 0,
                    fireRate: 250 // 射速 (ms)
                };
                bullets = [];
                enemies = [];
                missiles = [];
                score = 0;
                gameIsOver = false;
                lastEnemySpawn = Date.now();
                enemySpawnInterval = 1000; // 重置难度

                // 更新UI
                scoreDisplay.textContent = `得分: 0`;
                startMenu.style.display = 'none';
                gameOverMenu.style.display = 'none';
                canvas.style.display = 'block';
                scoreDisplay.style.display = 'block';
                fireButton.style.display = 'block';

                // 停止旧循环并开始新循环
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                gameLoop();
            }

            function triggerGameOver() {
                if (gameIsOver) return; // 防止重复触发
                
                gameIsOver = true;
                cancelAnimationFrame(gameLoopId);

                // 更新UI
                canvas.style.display = 'none';
                scoreDisplay.style.display = 'none';
                fireButton.style.display = 'none';
                gameOverMenu.style.display = 'block';
                
                finalScoreEl.textContent = score;
                saveHighScore(playerName, score);
            }

            // === 6. 移动端控制 ===
            
            // 阻止画布上的触摸默认行为（如滚动）
            canvas.addEventListener('touchstart', (e) => e.preventDefault());
            canvas.addEventListener('touchmove', (e) => e.preventDefault());

            // 1. 玩家移动 (跟随手指)
            function movePlayer(e) {
                if (gameIsOver || !player) return;
                let touch = e.touches[0];
                
                // 计算玩家中心位置
                player.x = touch.clientX - player.width / 2;
                player.y = touch.clientY - player.height / 2;

                // 边界检测
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            }
            canvas.addEventListener('touchstart', movePlayer);
            canvas.addEventListener('touchmove', movePlayer);

            // 2. 开火按钮 (按住即开火)
            // 'touchstart' 相当于 'mousedown'
            fireButton.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 防止触发点击等事件
                isFiring = true;
            });
            // 'touchend' 相当于 'mouseup'
            fireButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                isFiring = false;
            });

            // === 7. 游戏主循环 ===
            function gameLoop() {
                if (gameIsOver) return;

                update();
                draw();

                gameLoopId = requestAnimationFrame(gameLoop);
            }

            // === 8. 更新逻辑 (Update) ===
            function update() {
                // 1. 玩家开火
                if (isFiring && (Date.now() - player.lastShotTime > player.fireRate)) {
                    player.lastShotTime = Date.now();
                    bullets.push({
                        x: player.x + player.width / 2 - 2.5, // 子弹中心
                        y: player.y,
                        width: 5,
                        height: 15,
                        speed: 10
                    });
                }

                // 2. 更新子弹
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].y -= bullets[i].speed;
                    if (bullets[i].y < 0) {
                        bullets.splice(i, 1); // 移除飞出屏幕的子弹
                    }
                }

                // 3. 生成敌人
                if (Date.now() - lastEnemySpawn > enemySpawnInterval) {
                    lastEnemySpawn = Date.now();
                    
                    let isHomingType = Math.random() < 0.3; // 30% 几率是跟踪型
                    enemies.push({
                        x: Math.random() * (canvas.width - enemySize.width),
                        y: -enemySize.height,
                        width: enemySize.width,
                        height: enemySize.height,
                        speed: 2 + (score / 1000), // 速度随分数增加
                        isHoming: isHomingType,
                        img: isHomingType ? enemy2Img : enemy1Img,
                        lastMissileShot: 0,
                        missileRate: 2000 // 跟踪导弹射速
                    });

                    // 增加难度
                    if (enemySpawnInterval > 300) {
                        enemySpawnInterval -= 10;
                    }
                }

                // 4. 更新敌人
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let enemy = enemies[i];
                    enemy.y += enemy.speed;

                    // 飞出屏幕
                    if (enemy.y > canvas.height) {
                        enemies.splice(i, 1);
                        continue;
                    }

                    // 跟踪型敌人发射导弹
                    if (enemy.isHoming && (Date.now() - enemy.lastMissileShot > enemy.missileRate)) {
                        enemy.lastMissileShot = Date.now();
                        missiles.push({
                            // *** (修改 1) ***
                            x: enemy.x + enemy.width / 2 - 10, // 导弹更宽，中心点偏移
                            y: enemy.y + enemy.height,
                            width: 20,  // 变大：10 -> 20
                            height: 30, // 变大：20 -> 30
                            speed: 2.5 + (score / 3000) // 变慢：(4 + score/2000) -> (2.5 + score/3000)
                        });
                    }

                    // 碰撞检测：敌人 vs 玩家
                    if (checkCollision(player, enemy)) {
                        triggerGameOver();
                    }
                }

                // 5. 更新跟踪导弹
                for (let i = missiles.length - 1; i >= 0; i--) {
                    let missile = missiles[i];
                    
                    // === 跟踪逻辑 ===
                    let dx = (player.x + player.width / 2) - (missile.x + missile.width / 2);
                    let dy = (player.y + player.height / 2) - (missile.y + missile.height / 2);
                    let distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    missile.x += (dx / distance) * missile.speed;
                    missile.y += (dy / distance) * missile.speed;
                    // === 跟踪结束 ===

                    if (missile.y > canvas.height) {
                        missiles.splice(i, 1);
                        continue;
                    }

                    // 碰撞检测：导弹 vs 玩家
                    if (checkCollision(player, missile)) {
                        triggerGameOver();
                    }
                }

                // *** (修改 2) ***
                // 6. 碰撞检测：子弹 vs (敌人 or 导弹)
                for (let i = bullets.length - 1; i >= 0; i--) {
                    // 检查子弹是否存在 (可能在上一次迭代中被移除了)
                    if (!bullets[i]) continue;
                    
                    let bullet = bullets[i];
                    let bulletRemoved = false;

                    // 6a. 子弹 vs 敌人
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (checkCollision(bullet, enemies[j])) {
                            // 击中
                            score += 10;
                            
                            enemies.splice(j, 1); // 移除敌人
                            bullets.splice(i, 1); // 移除子弹
                            bulletRemoved = true;
                            break; // 子弹已消失，跳出内循环
                        }
                    }

                    if (bulletRemoved) {
                        continue; // 子弹已消失，检查下一颗
                    }

                    // 6b. 子弹 vs 导弹
                    for (let j = missiles.length - 1; j >= 0; j--) {
                        if (checkCollision(bullet, missiles[j])) {
                            // 击中导弹
                            score += 5; // 击落导弹+5分

                            missiles.splice(j, 1); // 移除导弹
                            bullets.splice(i, 1); // 移除子弹
                            break; // 子弹已消失，跳出内循环
                        }
                    }
                }
                
                // 统一更新分数显示
                scoreDisplay.textContent = `得分: ${score}`;
            }

            // === 9. 绘制逻辑 (Draw) ===
            function draw() {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制玩家
                if (playerImg.complete) {
                    ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = 'blue'; // 图片加载失败时的备用
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }

                // 绘制敌人
                enemies.forEach(enemy => {
                    if (enemy.img.complete) {
                        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        // 备用
                        ctx.fillStyle = enemy.isHoming ? 'red' : 'green';
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                });

                // 绘制子弹
                ctx.fillStyle = '#fff';
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });

                // 绘制导弹
                ctx.fillStyle = 'orange';
                missiles.forEach(missile => {
                    ctx.fillRect(missile.x, missile.y, missile.width, missile.height);
                });
            }

            // === 10. 辅助函数 ===
            
            // AABB 碰撞检测
            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            // 窗口大小改变时重置画布（在游戏中不推荐，但开始时需要）
            window.addEventListener('resize', () => {
                if (!gameIsOver) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });

        });
    </script>
</body>
</html>
