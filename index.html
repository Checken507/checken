<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>飞机大战 (史诗级) - 最终修复版 V2</title>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #111;
            color: #fff;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #000;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: none; 
            background-color: #000;
        }

        /* 菜单通用样式 */
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
        }

        /* 游戏内 UI */
        #score-display, #boss-hp-display {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            z-index: 5;
            display: none; 
        }
        #boss-hp-display {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            width: 80%;
            text-align: center;
        }

        /* 关键：开火按钮 */
        #fire-button {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%; 
            z-index: 5;
            display: none;
            -webkit-tap-highlight-color: transparent; 
        }
        #fire-button:active {
            background-color: rgba(255, 0, 0, 0.8); 
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="start-menu" class="menu">
            <h1>飞机大战</h1>
            <input type="text" id="player-name-input" placeholder="输入你的名字">
            <button id="start-button">开始游戏</button>
            <h3>本地最高分 (Top 10):</h3>
            <ol id="high-score-list"></ol>
        </div>

        <canvas id="game-canvas"></canvas>

        <div id="score-display">得分: 0</div>
        <div id="boss-hp-display" style="display: none;">BOSS 血量: 100</div>
        <button id="fire-button"></button>

        <div id="game-over-menu" class="menu" style="display: none;">
            <h2>游戏结束</h2>
            <p style="font-size: 20px; margin: 15px 0;">
                最终得分: <span id="final-score">0</span>
            </p>
            <button id="restart-button">重新开始</button>
            <button id="main-menu-button">返回主菜单</button>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // === 1. DOM 元素获取 ===
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const startMenu = document.getElementById('start-menu');
            const gameOverMenu = document.getElementById('game-over-menu');
            const startButton = document.getElementById('start-button');
            const restartButton = document.getElementById('restart-button');
            const mainMenuButton = document.getElementById('main-menu-button');
            const playerNameInput = document.getElementById('player-name-input');
            const highScoreList = document.getElementById('high-score-list');
            const finalScoreEl = document.getElementById('final-score');
            const scoreDisplay = document.getElementById('score-display');
            const bossHpDisplay = document.getElementById('boss-hp-display');
            const fireButton = document.getElementById('fire-button');

            // === 2. 游戏变量 & 常量 ===
            let player, bullets, enemies, missiles, boss, bossBullets, score, gameLoopId, playerName;
            let gameIsOver = false;
            let isFiring = false;
            let lastEnemySpawn = 0;
            let enemySpawnInterval = 1000;
            const playerSize = { width: 50, height: 50 };
            const enemySize = { width: 50, height: 50 };
            const bossSize = { width: 150, height: 100 };
            
            // BOSS 战常量
            const BOSS_SPAWN_SCORE = 700; // **修改点 2: Boss 出现分数改为 700**
            const BOSS_MAX_HP = 100;
            const BOSS_SHOT_DAMAGE = 1;
            const BOSS_FIRE_RATE = 1000;
            const SCATTER_BULLET_COUNT = 8;
            let bossSpawnFlag = 0;

            // 敌人 B (高血量) 属性
            let enemyBInitialHP = 3;
            const ENEMY_B_HP_INCREASE_RATE = 0.005;

            // 敌人 A (大范围平移) 属性
            let enemyAMoveSpeed = 3;
            const ENEMY_A_MAX_OFFSET = 200;

            // 敌人 C (对角线移动) 属性
            const ENEMY_C_DIAGONAL_SPEED = 3;
            
            // 敌人类型的生成概率
            // **修改点 1: 重新配置敌人生成概率，增加 ENEMY_C**
            const ENEMY_PROBABILITIES = [
                { type: 'NORMAL', chance: 0.35, key: 'normal' }, // 35%
                { type: 'HOMING', chance: 0.25, key: 'homing' }, // 25%
                { type: 'ENEMY_A', chance: 0.15, key: 'enemyA' }, // 15%
                { type: 'ENEMY_B', chance: 0.15, key: 'enemyB' }, // 15%
                { type: 'ENEMY_C', chance: 0.10, key: 'enemyC' }  // 10%
            ];

            // === 3. 加载贴图 ===
            const images = {};
            const imageSources = {
                player: 'assets/player.png',
                normal: 'assets/player1.png',
                homing: 'assets/player2.png',
                enemyA: 'assets/player3.png',
                enemyB: 'assets/player4.png',
                enemyC: 'assets/player5.png',
                boss: 'assets/boss.png'
            };
            let allImagesLoaded = false;

            function loadImages(callback) {
                let loadedCount = 0;
                let totalCount = Object.keys(imageSources).length;
                
                for (const key in imageSources) {
                    images[key] = new Image();
                    images[key].onload = () => {
                        loadedCount++;
                        if (loadedCount === totalCount) {
                            allImagesLoaded = true;
                            callback();
                        }
                    };
                    images[key].onerror = () => {
                        console.error(`Failed to load image: ${imageSources[key]}. Using fallback.`);
                        loadedCount++;
                        if (loadedCount === totalCount) {
                            allImagesLoaded = true;
                            callback();
                        }
                    };
                    images[key].src = imageSources[key];
                }
            }
            
            // === 4. 排行榜 (LocalStorage) - 略 ===
            const HIGH_SCORES_KEY = 'planeShooterHighScores';
            function getHighScores() {
                const scores = localStorage.getItem(HIGH_SCORES_KEY);
                return scores ? JSON.parse(scores) : [];
            }
            function saveHighScore(name, score) {
                if (score === 0) return;
                const scores = getHighScores();
                scores.push({ name, score });
                scores.sort((a, b) => b.score - a.score);
                const top10 = scores.slice(0, 10);
                localStorage.setItem(HIGH_SCORES_KEY, JSON.stringify(top10));
            }
            function displayHighScores() {
                const scores = getHighScores();
                highScoreList.innerHTML = '';
                if (scores.length === 0) {
                    highScoreList.innerHTML = '<li>暂无记录</li>';
                } else {
                    scores.forEach(item => {
                        const li = document.createElement('li');
                        li.textContent = `${item.name}: ${item.score}`;
                        highScoreList.appendChild(li);
                    });
                }
            }

            // === 5. 游戏状态管理 ===
            displayHighScores();
            startButton.addEventListener('click', () => {
                if (!allImagesLoaded) {
                    startButton.textContent = '加载中...';
                    startButton.disabled = true;
                    loadImages(startGame);
                } else {
                    startGame();
                }
            });
            restartButton.addEventListener('click', startGame);
            mainMenuButton.addEventListener('click', () => {
                gameOverMenu.style.display = 'none';
                startMenu.style.display = 'block';
                displayHighScores();
            });

            function startGame() {
                playerName = playerNameInput.value || '匿名玩家';
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                startButton.disabled = false;
                startButton.textContent = '开始游戏';


                // 初始化游戏
                player = { 
                    x: canvas.width / 2 - playerSize.width / 2, 
                    y: canvas.height - playerSize.height - 80,
                    width: playerSize.width, 
                    height: playerSize.height,
                    lastShotTime: 0,
                    fireRate: 250 
                };
                bullets = [];
                enemies = [];
                missiles = [];
                boss = null;
                bossBullets = [];
                score = 0;
                gameIsOver = false;
                lastEnemySpawn = Date.now();
                enemySpawnInterval = 1000;
                enemyBInitialHP = 3;
                enemyAMoveSpeed = 3;
                bossSpawnFlag = 0;

                // UI
                scoreDisplay.textContent = `得分: 0`;
                startMenu.style.display = 'none';
                gameOverMenu.style.display = 'none';
                canvas.style.display = 'block';
                scoreDisplay.style.display = 'block';
                fireButton.style.display = 'block';
                bossHpDisplay.style.display = 'none';


                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                gameLoop(Date.now());
            }

            function triggerGameOver() {
                if (gameIsOver) return;
                
                gameIsOver = true;
                cancelAnimationFrame(gameLoopId);
                
                canvas.style.display = 'none';
                scoreDisplay.style.display = 'none';
                fireButton.style.display = 'none';
                bossHpDisplay.style.display = 'none';
                gameOverMenu.style.display = 'block';
                
                finalScoreEl.textContent = score;
                saveHighScore(playerName, score);
            }

            // === 6. 移动端控制 - 略 ===
            canvas.addEventListener('touchstart', (e) => e.preventDefault());
            canvas.addEventListener('touchmove', (e) => e.preventDefault());
            function movePlayer(e) {
                if (gameIsOver || !player) return;
                let touch = e.touches[0];
                player.x = touch.clientX - player.width / 2;
                player.y = touch.clientY - player.height / 2;
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            }
            canvas.addEventListener('touchstart', movePlayer);
            canvas.addEventListener('touchmove', movePlayer);
            
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); isFiring = true; });
            fireButton.addEventListener('touchend', (e) => { e.preventDefault(); isFiring = false; });
            fireButton.addEventListener('touchcancel', (e) => { e.preventDefault(); isFiring = false; });

            // === 7. 游戏主循环 ===
            let lastTime = Date.now();
            function gameLoop(timestamp) {
                if (gameIsOver) return;
                
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;

                update(deltaTime / 1000);
                draw();

                gameLoopId = requestAnimationFrame(gameLoop);
            }

            // === 8. 更新逻辑 (Update) ===
            function update(dt) {
                // 难度/生命值随时间增加
                enemyBInitialHP += ENEMY_B_HP_INCREASE_RATE * dt;
                enemyAMoveSpeed += 0.05 * dt;

                // 1. 玩家开火
                if (isFiring && (Date.now() - player.lastShotTime > player.fireRate)) {
                    player.lastShotTime = Date.now();
                    bullets.push({
                        x: player.x + player.width / 2 - 2.5,
                        y: player.y,
                        width: 5,
                        height: 15,
                        speed: 10,
                        damage: 1
                    });
                }
                
                // 2. BOSS 出现逻辑
                // requiredBossMultiple 将是 1 (700-1399), 2 (1400-2099), 3 (2100-2799)...
                const requiredBossMultiple = Math.floor(score / BOSS_SPAWN_SCORE); 
                if (requiredBossMultiple > bossSpawnFlag) {
                    bossSpawnFlag = requiredBossMultiple;
                    spawnBoss();
                }

                // 3. 更新子弹
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].y -= bullets[i].speed;
                    if (bullets[i].y < 0) {
                        bullets.splice(i, 1);
                    }
                }
                
                // 4. 生成敌人 (Boss 存在时不生成)
                if (!boss) {
                    if (Date.now() - lastEnemySpawn > enemySpawnInterval) {
                        lastEnemySpawn = Date.now();
                        spawnRandomEnemy(); // **修改点 1: 移除 isEnemyC 参数**
                        if (enemySpawnInterval > 300) {
                            enemySpawnInterval -= 10;
                        }
                    }
                    // **修改点 1: 移除独立的 ENEMY_C 生成逻辑**
                }

                // 5. 更新敌人
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let enemy = enemies[i];

                    if (enemy.type === 'ENEMY_A') {
                        enemy.x += enemy.moveDirection * enemyAMoveSpeed * dt * 60;
                        let currentOffset = enemy.x - enemy.initialX;
                        if (currentOffset > ENEMY_A_MAX_OFFSET) {
                            enemy.moveDirection = -1;
                        } else if (currentOffset < -ENEMY_A_MAX_OFFSET) {
                            enemy.moveDirection = 1;
                        }
                    } else if (enemy.type === 'ENEMY_C') {
                        // 对角线移动
                        enemy.x += enemy.moveDirectionX * ENEMY_C_DIAGONAL_SPEED * dt * 60 * 0.5;
                        enemy.y += ENEMY_C_DIAGONAL_SPEED * dt * 60 * 0.5;
                    }
                    
                    if (enemy.type !== 'ENEMY_C') {
                        enemy.y += enemy.speed * dt * 60;
                    }

                    if (enemy.type === 'HOMING' && (Date.now() - enemy.lastMissileShot > enemy.missileRate)) {
                        enemy.lastMissileShot = Date.now();
                        missiles.push(createMissile(enemy));
                    }

                    if (enemy.y > canvas.height || enemy.x < -enemy.width || enemy.x > canvas.width) {
                        enemies.splice(i, 1);
                        continue;
                    }

                    if (checkCollision(player, enemy)) {
                        triggerGameOver();
                        return;
                    }
                }
                
                // 6. 更新跟踪导弹
                for (let i = missiles.length - 1; i >= 0; i--) {
                    let missile = missiles[i];
                    
                    // 追踪导弹优化: 只有当导弹的 Y 坐标小于玩家 Y 坐标时才追踪
                    if (missile.y < player.y + player.height / 2) {
                        updateMissile(missile, player);
                    } else {
                        // 停止追踪，继续自由落体/当前速度
                        if (!missile.isFreefall) {
                            missile.isFreefall = true;
                            // 修正：确保 missile.velocityY 至少是向下速度
                            missile.velocityY = Math.abs(missile.velocityY) + 1; 
                        }
                        
                        missile.x += missile.velocityX;
                        missile.y += missile.velocityY;

                        // 移除逻辑
                        if (missile.y > player.y + 200) {
                            missiles.splice(i, 1);
                            continue;
                        }
                    }

                    if (missile.y > canvas.height) {
                        missiles.splice(i, 1);
                        continue;
                    }

                    // 碰撞检测：导弹 vs 玩家
                    if (checkCollision(player, missile)) {
                        triggerGameOver();
                        return;
                    }
                }

                // 7. BOSS 逻辑
                if (boss) {
                    updateBoss(dt);
                }

                // 8. 更新 BOSS 子弹
                for (let i = bossBullets.length - 1; i >= 0; i--) {
                    let bBullet = bossBullets[i];
                    bBullet.x += bBullet.velocityX * dt * 60;
                    bBullet.y += bBullet.velocityY * dt * 60;
                    
                    if (bBullet.y > canvas.height || bBullet.x < 0 || bBullet.x > canvas.width) {
                        bossBullets.splice(i, 1);
                        continue;
                    }

                    if (checkCollision(player, bBullet)) {
                        triggerGameOver();
                        return;
                    }
                }

                // 9. 碰撞检测：玩家子弹 vs (敌人 or 导弹 or Boss)
                for (let i = bullets.length - 1; i >= 0; i--) {
                    let bullet = bullets[i];
                    let bulletRemoved = false;
                    
                    // a. 子弹 vs 敌人
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (checkCollision(bullet, enemies[j])) {
                            enemies[j].health -= bullet.damage;
                            
                            if (enemies[j].health <= 0) {
                                score += 10;
                                enemies.splice(j, 1);
                            }

                            bullets.splice(i, 1);
                            bulletRemoved = true;
                            break;
                        }
                    }

                    if (bulletRemoved) continue;

                    // b. 子弹 vs 导弹
                    for (let j = missiles.length - 1; j >= 0; j--) {
                        if (checkCollision(bullet, missiles[j])) {
                            score += 5;
                            missiles.splice(j, 1);
                            bullets.splice(i, 1);
                            bulletRemoved = true;
                            break;
                        }
                    }
                    
                    if (bulletRemoved) continue;

                    // c. 子弹 vs BOSS
                    if (boss && checkCollision(bullet, boss) && !boss.isInvincible) {
                        boss.health -= bullet.damage;
                        score += 1;
                        
                        bullets.splice(i, 1); 
                        bulletRemoved = true;

                        if (boss.health <= 0) {
                            boss = null;
                            score += 100;
                            bossHpDisplay.style.display = 'none';
                        }
                    }
                }
                
                scoreDisplay.textContent = `得分: ${score}`;
                if (boss) {
                    bossHpDisplay.textContent = `BOSS 血量: ${Math.max(0, boss.health)} / ${BOSS_MAX_HP}`;
                }
            }
            
            // --- 辅助函数 ---

            function spawnRandomEnemy() {
                let chosenType = null;
                
                // **修改点 1: 根据权重随机选择所有敌人类型**
                let rand = Math.random();
                let cumulativeChance = 0;
                for (const { type, chance } of ENEMY_PROBABILITIES) {
                    cumulativeChance += chance;
                    if (rand < cumulativeChance) {
                        chosenType = type;
                        break;
                    }
                }
                
                if (!chosenType) return;

                let enemy = {
                    width: enemySize.width,
                    height: enemySize.height,
                    speed: 2 + (score / 1000),
                    type: chosenType,
                    img: images[ENEMY_PROBABILITIES.find(e => e.type === chosenType).key]
                };

                if (chosenType === 'ENEMY_B') {
                    enemy.health = Math.ceil(enemyBInitialHP);
                } else {
                    enemy.health = 1;
                }
                
                if (chosenType === 'HOMING') {
                    enemy.lastMissileShot = Date.now();
                    enemy.missileRate = 2000;
                }

                if (chosenType === 'ENEMY_A') {
                    let minX = ENEMY_A_MAX_OFFSET;
                    let maxX = canvas.width - enemy.width - ENEMY_A_MAX_OFFSET;
                    enemy.initialX = Math.random() * (maxX - minX) + minX;
                    enemy.x = enemy.initialX;
                    enemy.y = -enemy.height;
                    enemy.moveDirection = Math.random() < 0.5 ? -1 : 1;
                } else if (chosenType === 'ENEMY_C') {
                    // 对角线移动敌人 C
                    let startRight = Math.random() < 0.5;
                    enemy.x = startRight ? canvas.width - enemy.width : 0;
                    enemy.y = 0;
                    enemy.moveDirectionX = startRight ? -1 : 1;
                } else {
                    enemy.x = Math.random() * (canvas.width - enemy.width);
                    enemy.y = -enemy.height;
                }

                enemies.push(enemy);
            }

            function createMissile(enemy) {
                return {
                    x: enemy.x + enemy.width / 2 - 10,
                    y: enemy.y + enemy.height,
                    width: 20,
                    height: 30,
                    speed: 2.5 + (score / 3000),
                    velocityX: 0, 
                    velocityY: 0,
                    isFreefall: false 
                };
            }

            function updateMissile(missile, target) {
                let dx = (target.x + target.width / 2) - (missile.x + missile.width / 2);
                let dy = (target.y + target.height / 2) - (missile.y + missile.height / 2);
                let distance = Math.sqrt(dx * dx + dy * dy) || 1;
                
                missile.velocityX = (dx / distance) * missile.speed * 0.016 * 60;
                missile.velocityY = (dy / distance) * missile.speed * 0.016 * 60;
                
                missile.x += missile.velocityX;
                missile.y += missile.velocityY;
            }

            function spawnBoss() {
                enemies = [];
                missiles = [];
                
                ctx.fillStyle = 'yellow';
                ctx.font = '40px Arial';
                ctx.fillText("青云出没！", canvas.width / 2 - 100, canvas.height / 2);
                
                setTimeout(() => {
                    boss = {
                        x: canvas.width / 2 - bossSize.width / 2,
                        y: 100,
                        width: bossSize.width,
                        height: bossSize.height,
                        health: BOSS_MAX_HP,
                        lastShotTime: Date.now() + 1000,
                        type: 'BOSS',
                        img: images.boss,
                        isInvincible: true
                    };
                    bossHpDisplay.style.display = 'block';
                }, 500); 
            }

            function updateBoss(dt) {
                if (boss.health <= 0) return;

                if (boss.isInvincible && Date.now() - boss.lastShotTime > 500) {
                    boss.isInvincible = false;
                }

                if (!boss.isInvincible && Date.now() - boss.lastShotTime > BOSS_FIRE_RATE) {
                    boss.lastShotTime = Date.now();
                    
                    const angleStep = (Math.PI * 2) / SCATTER_BULLET_COUNT;
                    const bossBulletSpeed = 5;

                    for (let i = 0; i < SCATTER_BULLET_COUNT; i++) {
                        let angle = i * angleStep;
                        
                        const startX = boss.x + boss.width / 2;
                        const startY = boss.y + boss.height / 2;

                        bossBullets.push({
                            x: startX,
                            y: startY,
                            width: 15,
                            height: 15,
                            damage: BOSS_SHOT_DAMAGE,
                            velocityX: Math.cos(angle) * bossBulletSpeed,
                            velocityY: Math.sin(angle) * bossBulletSpeed
                        });
                    }
                }
            }


            // === 9. 绘制逻辑 (Draw) ===
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制 BOSS 子弹
                ctx.fillStyle = 'red';
                bossBullets.forEach(bBullet => {
                    ctx.fillRect(bBullet.x, bBullet.y, bBullet.width, bBullet.height);
                });

                // 绘制玩家
                if (images.player.complete) {
                    ctx.drawImage(images.player, player.x, player.y, player.width, player.height);
                }

                // 绘制 BOSS
                if (boss && images.boss.complete) {
                    ctx.drawImage(images.boss, boss.x, boss.y, boss.width, boss.height);
                }

                // 绘制敌人
                enemies.forEach(enemy => {
                    if (enemy.img && enemy.img.complete) {
                        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                    // 绘制敌人 B 的血条
                    if (enemy.type === 'ENEMY_B') {
                         ctx.fillStyle = 'lime';
                         const maxHP = Math.ceil(enemyBInitialHP);
                         const currentHP = enemy.health;
                         ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (currentHP / maxHP), 5);
                    }
                });

                // 绘制子弹
                ctx.fillStyle = '#fff';
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });

                // 绘制导弹
                ctx.fillStyle = 'orange';
                missiles.forEach(missile => {
                    ctx.fillRect(missile.x, missile.y, missile.width, missile.height);
                });
            }

            // === 10. 辅助函数 ===
            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            window.addEventListener('resize', () => {
                if (!gameIsOver) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });

        });
    </script>
</body>
</html>
